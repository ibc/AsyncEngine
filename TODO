TODO
****



assert()
--------

Add assert() in all the uv functions in which I do not check the return code.



`write': deadlock; recursive locking (ThreadError)
--------------------------------------------------

  trap(:INT)  { puts "*** INT trapped => ignore" }
  AE.run do
    Thread.new { loop { puts "---t1---" ; sleep 0.001 } }
    Thread.new { loop { puts "---t2---" ; sleep 0.001 } }
    AE.add_periodic_timer(0.001) { puts "***AE timer 1***" }
    AE.add_periodic_timer(0.001) { puts "***AE timer 2***" }
  end

If during the loop I press *multiple* times Ctrl+C (so INT signal) I get this error:

  /home/ibc/Proyectos/AsyncEngine/test/test01.rb:9:in `write': deadlock; recursive locking (ThreadError)
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:9:in `puts'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:9:in `puts'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:9:in `block in <top (required)>'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:21:in `call'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:21:in `write'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:21:in `puts'

NOTE: The same occurs in EventMachine !!!



SIGPIPE received
----------------

From libev documentation:

http://doc.dvgu.ru/devel/ev.html#the_special_problem_of_sigpipe
-----
The special problem of SIGPIPE

While not really specific to libev, it is easy to forget about SIGPIPE: when reading from a pipe whose other end has been closed, your program gets send a SIGPIPE, which, by default, aborts your program. For most programs this is sensible behaviour, for daemons, this is usually undesirable.

So when you encounter spurious, unexplained daemon exits, make sure you ignore SIGPIPE (and maybe make sure you log the exit status of your daemon somewhere, as that would have given you a big clue).
-----

So maybe AsyncEngine should trap and ignore SIGPIPE from the beginning.

UPDATE: Ruby ignores PIPE signal by default, and also uv so nothing must be done.



Wait for uv_run_nowait()
------------------------

https://github.com/joyent/libuv/issues/410



uv_inet_pton/ntop
-----------------

https://github.com/saghul/pyuv/blob/master/src/pyuv.h#L269



uv_bind_udp() multiple times with same bind address
---------------------------------------------------

https://github.com/joyent/libuv/issues/412

RESPONSE: It's a feature, libuv sets the SO_REUSEADDR flag on both sockets. Both are able to send but only the second socket can receive datagrams.



Ruby DATA_PTR
-------------

file.c:

/*
 * call-seq:
 *
 *   File::Stat.new(file_name)  -> stat
 *
 * Create a File::Stat object for the given file name (raising an
 * exception if the file doesn't exist).
 */

static VALUE
rb_stat_init(VALUE obj, VALUE fname)
{
    struct stat st, *nst;

    rb_secure(2);
    FilePathValue(fname);
    fname = rb_str_encode_ospath(fname);
    if (STAT(StringValueCStr(fname), &st) == -1) {
        rb_sys_fail(RSTRING_PTR(fname));
    }
    if (DATA_PTR(obj)) {
        xfree(DATA_PTR(obj));
        DATA_PTR(obj) = NULL;
    }
    nst = ALLOC(struct stat);
    *nst = st;
    DATA_PTR(obj) = nst;

    return Qnil;
}

static VALUE
rb_stat_init_copy(VALUE copy, VALUE orig)
{
    struct stat *nst;

    if (copy == orig) return orig;
    rb_check_frozen(copy);
    /* need better argument type check */
    if (!rb_obj_is_instance_of(orig, rb_obj_class(copy))) {
        rb_raise(rb_eTypeError, "wrong argument class");
    }
    if (DATA_PTR(copy)) {
        xfree(DATA_PTR(copy));
        DATA_PTR(copy) = 0;
    }
    if (DATA_PTR(orig)) {
        nst = ALLOC(struct stat);
        *nst = *(struct stat*)DATA_PTR(orig);
        DATA_PTR(copy) = nst;
    }

    return copy;
}
