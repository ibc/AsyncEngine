TODO
****



UV Refcount refactor
--------------------

In master:.

https://github.com/joyent/libuv/commit/9efa8b35713ae2a1c2ba2300e54492861f1af1e5



BUG: multithread BIG problems
------------------------------

http://bugs.ruby-lang.org/issues/6433

The problem seems a bit fixed, but not 100%. In fact, given the following code:

  loop do AE.run { AE.next_tick { AE.next_tick { } } } end

If I send a STOP/INT signal to that process, I get:

  ruby: asyncengine_ruby.c:33: run_uv_without_gvl: Assertion `! _uv_is_running' failed.

and that is because _c_run was calling with _uv_is_running being true!!!

UPDATE: Theorically fixed...

However another critical bug (see bug_timer_frozen.rb):

  AE.run { AE::PeriodicTimer.new(1) { puts "TICK" } }

Sending a signal to this process makes it frozen (so kill -9 required...).




WARNING: I manage Ruby objects without GVL
------------------------------------------

C callbacks remove elements from the @_handles Hash without the GVL. It's not *very* dangerous since keys are FIXNUM
(immutable) but:

"Fixnum instances are immutable and calling #hash should be safe on them.
However, point 2) stands: if two threads will access the hash simultaneously,
that may and will lead to crashes."



assert()
--------

Add assert() in all the uv functions in which I do not check the return code.



`write': deadlock; recursive locking (ThreadError)
--------------------------------------------------

  trap(:INT)  { puts "*** INT trapped => ignore" }
  AE.run do
    Thread.new { loop { puts "---t1---" ; sleep 0.001 } }
    Thread.new { loop { puts "---t2---" ; sleep 0.001 } }
    AE.add_periodic_timer(0.001) { puts "***AE timer 1***" }
    AE.add_periodic_timer(0.001) { puts "***AE timer 2***" }
  end

If during the loop I press *multiple* times Ctrl+C (so INT signal) I get this error:

  /home/ibc/Proyectos/AsyncEngine/test/test01.rb:9:in `write': deadlock; recursive locking (ThreadError)
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:9:in `puts'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:9:in `puts'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:9:in `block in <top (required)>'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:21:in `call'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:21:in `write'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:21:in `puts'

NOTE: The same occurs in EventMachine !!!



SIGPIPE received
----------------

From libev documentation:

http://doc.dvgu.ru/devel/ev.html#the_special_problem_of_sigpipe
-----
The special problem of SIGPIPE

While not really specific to libev, it is easy to forget about SIGPIPE: when reading from a pipe whose other end has been closed, your program gets send a SIGPIPE, which, by default, aborts your program. For most programs this is sensible behaviour, for daemons, this is usually undesirable.

So when you encounter spurious, unexplained daemon exits, make sure you ignore SIGPIPE (and maybe make sure you log the exit status of your daemon somewhere, as that would have given you a big clue).
-----

So maybe AsyncEngine should trap and ignore SIGPIPE from the beginning.

UPDATE: Ruby ignores PIPE signal by default, and also uv so nothing must be done.



Wait for uv_run_nowait()
------------------------

https://github.com/joyent/libuv/issues/410



uv_inet_pton/ntop
-----------------

https://github.com/saghul/pyuv/blob/master/src/pyuv.h#L269



uv_bind_udp() multiple times with same bind address
---------------------------------------------------

https://github.com/joyent/libuv/issues/412

RESPONSE: It's a feature, libuv sets the SO_REUSEADDR flag on both sockets. Both are able to send but only the second socket can receive datagrams.


Bugs reported in Github UV:
---------------------------

- https://github.com/joyent/libuv/issues/417


Ctrl+C in IRB:
-------------

irb> EM.run { EM.add_periodic_timer(1) {puts "QWE"} }

If I press Ctrl+C now, it terminates and EM.reactor_running? returns false. I don't get it in AE, maybe it's about trapping interrupt signal?

EM does this in em.cpp:

  TRAP_BEG; = rb_enable_interrupt()
  s = epoll_wait (epfd, epoll_events, MaxEvents, 0);
  TRAP_END; do { rb_disable_interrupt(); rb_thread_check_ints(); } while(0)

¿Usar rb_thread_interrupted() (GVL safe) para algo? ¿para qué es?