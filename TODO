TODO
****



BUG: multithread BIG problems
------------------------------

http://bugs.ruby-lang.org/issues/6433

From Tony Arcieri:

----------
The unblocking function doesn't run inside the blocking thread, it
runs from the running thread which by definition holds the GVL
---------- 



WARNING: I manage Ruby objects without GVL
------------------------------------------

C callbacks remove elements from the @_handles Hash without the GVL. It's not *very* dangerous since keys are FIXNUM
(immutable) but:

"Fixnum instances are immutable and calling #hash should be safe on them.
However, point 2) stands: if two threads will access the hash simultaneously,
that may and will lead to crashes."



assert()
--------

Add assert() in all the uv functions in which I do not check the return code.



`write': deadlock; recursive locking (ThreadError)
--------------------------------------------------

  trap(:INT)  { puts "*** INT trapped => ignore" }
  AE.run do
    Thread.new { loop { puts "---t1---" ; sleep 0.001 } }
    Thread.new { loop { puts "---t2---" ; sleep 0.001 } }
    AE.add_periodic_timer(0.001) { puts "***AE timer 1***" }
    AE.add_periodic_timer(0.001) { puts "***AE timer 2***" }
  end

If during the loop I press *multiple* times Ctrl+C (so INT signal) I get this error:

  /home/ibc/Proyectos/AsyncEngine/test/test01.rb:9:in `write': deadlock; recursive locking (ThreadError)
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:9:in `puts'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:9:in `puts'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:9:in `block in <top (required)>'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:21:in `call'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:21:in `write'
        from /home/ibc/Proyectos/AsyncEngine/test/test01.rb:21:in `puts'

NOTE: The same occurs in EventMachine !!!



SIGPIPE received
----------------

From libev documentation:

http://doc.dvgu.ru/devel/ev.html#the_special_problem_of_sigpipe
-----
The special problem of SIGPIPE

While not really specific to libev, it is easy to forget about SIGPIPE: when reading from a pipe whose other end has been closed, your program gets send a SIGPIPE, which, by default, aborts your program. For most programs this is sensible behaviour, for daemons, this is usually undesirable.

So when you encounter spurious, unexplained daemon exits, make sure you ignore SIGPIPE (and maybe make sure you log the exit status of your daemon somewhere, as that would have given you a big clue).
-----

So maybe AsyncEngine should trap and ignore SIGPIPE from the beginning.

UPDATE: Ruby ignores PIPE signal by default, and also uv so nothing must be done.



Wait for uv_run_nowait()
------------------------

https://github.com/joyent/libuv/issues/410



uv_inet_pton/ntop
-----------------

https://github.com/saghul/pyuv/blob/master/src/pyuv.h#L269



uv_bind_udp() multiple times with same bind address
---------------------------------------------------

https://github.com/joyent/libuv/issues/412

RESPONSE: It's a feature, libuv sets the SO_REUSEADDR flag on both sockets. Both are able to send but only the second socket can receive datagrams.

